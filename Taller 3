import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt


#1.a)

m = 10 ; v0 = 10; g = 9.773 ; b = 0
 
# Ecuaciones de movimiento con fricción
def motion_equations(t, y):
    ux, uy, x, y_pos = y
    speed = np.sqrt(ux**2 + uy**2)**2 
    dux_dt = -b * ux * speed / m
    duy_dt = -g - b * uy * speed / m
    dx_dt = ux ; dy_dt = uy
    return [dux_dt, duy_dt, dx_dt, dy_dt]

#Arreglo para el valor dónde el piso toca el suelo 
def hit_ground(t, y):
    return y[3] 
hit_ground.terminal = True #Termina la integración cuando el evento que tocó el piso acabó
hit_ground.direction = -1 # Cambia la dirección del evento 

angles = np.linspace(0, 90, 91); ranges = []; max_range = 0; best_angle = 0

for angle in angles:
    rad = np.radians(angle)
    initial_conditions = [v0 * np.cos(rad), v0 * np.sin(rad), 0, 0]
    sol = solve_ivp(motion_equations, [0, 10], initial_conditions, events=hit_ground, dense_output=False)
    
    if sol.t_events[0].size > 0: 
        range_at_angle = sol.y_events[0][0, 2]
        ranges.append(range_at_angle)
        if range_at_angle > max_range:
            max_range = range_at_angle
            best_angle = angle
    else:
        ranges.append(0)

print(f"El ángulo óptimo para 𝛽 {b}: {best_angle}° con un alcance de: {max_range:.2f}.")

#1.b) 
E_initial = 0.5 * m * v0**2 ; betas = np.linspace(0, 2, 91)

def hit_ground(t, y, beta):
    return y[3]
hit_ground.terminal = True
hit_ground.direction = -1

def motion(t, y, beta):
    ux, uy, x, y_pos, energy_acc = y 
    speed = np.sqrt(ux**2 + uy**2)
    dux_dt = -beta * ux * speed / m
    duy_dt = -g - beta * uy * speed / m
    dx_dt = ux ; dy_dt = uy
    power_friction = beta * speed**3 
    return [dux_dt, duy_dt, dx_dt, dy_dt, power_friction]

best_angles = []; energy_losses = []

for beta in betas:
    max_range = 0; best_angle = 0
    for angle in np.linspace(0, 90, 91):
        rad = np.radians(angle)
        initial_conditions = [v0 * np.cos(rad), v0 * np.sin(rad), 0, 0, 0]
        sol = solve_ivp(motion, [0, 10], initial_conditions, args=(beta,), events=hit_ground, dense_output=False)
        
        if sol.t_events[0].size > 0:
            range_at_angle = sol.y_events[0][0, 2]
            if range_at_angle > max_range:
                max_range = range_at_angle ; best_angle = angle
    
    rad = np.radians(best_angle)
    initial_conditions = [v0 * np.cos(rad), v0 * np.sin(rad), 0, 0, 0]
    sol = solve_ivp(motion, [0, 10], initial_conditions, args=(beta,), events=hit_ground, vectorized=True, dense_output=True)
    if sol.y.shape[1] > 0:
        energy_lost = np.trapz(sol.y[4], sol.t)  
        energy_losses.append(energy_lost)
    else:
        energy_losses.append(0)
    
    best_angles.append(best_angle)

fig, ax = plt.subplots(2, 1, figsize=(12, 12))

ax[0].step(betas, best_angles, where='mid', label='Ángulo óptimo', color='yellow')
ax[0].set_xscale('log')
ax[0].set_title('θ vs. β')
ax[0].set_xlabel(' β')
ax[0].set_ylabel(' θ (grados)')
ax[0].grid(True)

ax[1].step(betas, best_angles, where='mid', label='Ángulo óptimo', color='yellow')
ax[1].set_title('θ vs  β')
ax[1].set_xlabel('β')
ax[1].set_ylabel(' θ (grados)')
ax[1].grid(True)
plt.savefig("1.a).pdf")

fig, ax = plt.subplots(2, 1, figsize=(12, 12))

ax[0].step(betas, energy_losses, where='mid', label='Ángulo óptimo', color='yellow')
ax[0].set_xscale('log')
ax[0].set_title('θ vs β')
ax[0].set_xlabel(' β')
ax[0].set_ylabel(' θ (grados)')
ax[0].grid(True)

ax[1].step(betas, energy_losses, where='mid', label='Ángulo óptimo', color='yellow')
ax[1].set_title('θ vs. β')
ax[1].set_xlabel(' β')
ax[1].set_ylabel(' θ (grados)')
plt.savefig("1.b).pdf")



