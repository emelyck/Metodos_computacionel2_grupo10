# -*- coding: utf-8 -*-

"""Tarea_1.ipynb

Automatically generated by Colab.

Original file is located at:
    https://colab.research.google.com/drive/1haLX2xPZSPqTA42zTUoRZ90Gmpaj_UdA
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math
from scipy.signal import find_peaks, peak_widths
from scipy.optimize import curve_fit
from scipy.interpolate import interp1d
from tabulate import tabulate
from shapely.geometry import Polygon

"""# 1. Tubo de rayos X

## 1.a. Limpieza
"""

Espectro = pd.read_csv('Rhodium.csv')
Intensidad = Espectro['Intensity (mJy)']
Longitud = Espectro['Wavelength (pm)']

Intensidad_check = np.array([])
Longitud_check = np.array([])
eliminados = 0

for i in range(1,len(Intensidad)-1):
  prom = (Intensidad[i-1] + Intensidad[i+1])/2

  if Intensidad[i] <= prom + 18*np.abs(prom -Intensidad[i-1]):
    Intensidad_check = np.append(Intensidad_check,Intensidad[i])
    Longitud_check = np.append(Longitud_check,Longitud[i])

  else:
    eliminados += 1

fig, axs = plt.subplots(2,1, figsize=(15,12))

#Figura 1
axs[0].plot(Longitud, Intensidad,marker='o', color='blue')
axs[0].set_xlabel('Longitud de onda (pm)', fontsize=12)
axs[0].set_ylabel('Intensidad (mJy)', fontsize=12)
axs[0].set_title('Gráfica de Espectro con ruido', fontsize=18)

#Figura 2
axs[1].plot(Longitud_check, Intensidad_check, marker='o', color='blue')
axs[1].set_xlabel('Longitud de onda (pm)', fontsize=12)
axs[1].set_ylabel('Intensidad (mJy)', fontsize=12)
axs[1].set_title('Gráfica de Espectro sin ruido ', fontsize=18)

#Ajuste
plt.tight_layout()

plt.show()

print(f'Se eliminaron {eliminados} puntos')

"""# 1.b Modelamiento"""

# Función gaussiana
def gaussian(x, amplitude, mean, stddev):
    return amplitude * np.exp(-((x - mean) / stddev)**2 / 2)

# Filtrar datos
Espectro_check = pd.DataFrame({'Wavelength (pm)': Longitud_check, 'Intensity (mJy)': Intensidad_check})

data2 = Espectro_check[~np.logical_or((Longitud_check >= 75) & (Longitud_check <= 85), (Longitud_check >= 95) & (Longitud_check <= 110))]

Longitud_fondo = data2['Wavelength (pm)']
Intensidad_fondo = data2['Intensity (mJy)']

Fondo = np.linspace(Longitud_fondo.min(), Longitud_fondo.max(), num=len(Longitud_check))

# Guardar los datos que fueron excluidos en data2
data3 = Espectro_check[np.logical_or((Longitud_check >= 75) & (Longitud_check <= 85), (Longitud_check >= 95) & (Longitud_check <= 110))]
Longitud_picos = data3['Wavelength (pm)']
Intensidad_picos = data3['Intensity (mJy)']

# Ajustar la función a los datos
popt, pcov = curve_fit(gaussian, Longitud_fondo, Intensidad_fondo, p0=[1.0, 100.0, 10.0])

# Extraer los parámetros ajustados
A, μ, σ = popt

# Graficar fondo y picos
fig, ax = plt.subplots(2, 1, figsize=(15, 10))

#Gráfica de los picos
ax[0].plot(Longitud_picos, Intensidad_picos, "o-", label='Curvas de los picos', color='blue')
ax[0].set_xlabel('Longitud de onda (pm)', fontsize=16)
ax[0].set_ylabel('Intensidad (mJy)', fontsize=16)
ax[0].set_title('Picos característicos', fontsize=18)
ax[0].set_xlim(-5, 315)
ax[0].set_ylim(0, 0.23)
ax[0].grid(True)
ax[0].legend(fontsize=15)

# Gráfica del fondo
ax[1].plot(Fondo, gaussian(Fondo, *popt), "o-", label='Ajuste gaussiano del fondo', color='orange')
ax[1].set_xlabel('Longitud de onda (pm)', fontsize=16)
ax[1].set_ylabel('Intensidad (mJy)', fontsize=16)
ax[1].set_title('Radiación de frenado', fontsize=18)
ax[1].set_xlim(-5, 315)
ax[1].set_ylim(0, 0.23)
ax[1].grid(True)
ax[1].legend(fontsize=15)

plt.tight_layout()
plt.show()


plt.close()

# Resumen del método
resumen = 'Regresión gaussiana del fondo'
print(f'1.b) Método: {resumen}')

"""## 1.c"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


espectro = pd.read_csv('Rhodium.csv')
intensidad = espectro['Intensity (mJy)'].values
longitud = espectro['Wavelength (pm)'].values

try:
    picos, _ = find_peaks(intensidad, height=0)
    anchos_fwhm = peak_widths(intensidad, picos, rel_height=0.5)
    resultados = []
    for i, pico in enumerate(picos):
        longitud_maxima = longitud[pico]
        intensidad_maxima = intensidad[pico]
        fwhm = anchos_fwhm[0][i] * (longitud[1] - longitud[0])

        resultados.append(
            ["Espectro fondo", f"Pico {i + 1}", f"{longitud_maxima:.4f} pm", f"{intensidad_maxima:.4f} mJy", f"{fwhm:.4f} pm"]
        )
    picos_caracteristicos = espectro[
        (espectro["Wavelength (pm)"].between(75, 85)) | (espectro["Wavelength (pm)"].between(95, 110))
    ]
    intensidad_picos = picos_caracteristicos['Intensity (mJy)'].values
    longitud_picos = picos_caracteristicos['Wavelength (pm)'].values
    picos_en_filtrado, _ = find_peaks(intensidad_picos, height=0)
    anchos_fwhm_filtrado = peak_widths(intensidad_picos, picos_en_filtrado, rel_height=0.5)
    for i, pico in enumerate(picos_en_filtrado):
        longitud_maxima = longitud_picos[pico]
        intensidad_maxima = intensidad_picos[pico]
        fwhm = anchos_fwhm_filtrado[0][i] * (longitud_picos[1] - longitud_picos[0])

        resultados.append(
            ["Picos característicos", f"Pico {i + 1}", f"{longitud_maxima:.4f} pm", f"{intensidad_maxima:.4f} mJy", f"{fwhm:.4f} pm"]
        )
    encabezados = ["Espectro", "Identificación", "Longitud máxima", "Intensidad máxima", "FWHM"]
    print(tabulate(resultados, headers=encabezados, tablefmt="grid"))

except Exception as e:
    print("Ocurrió un error al analizar los picos:")
    print(e)

espectro = pd.read_csv('Rhodium.csv')
longitud = espectro['Wavelength (pm)'].values * 1e-12

intensidad = espectro['Intensity (mJy)'].values * 1e-3
energia_total = np.trapezoid(intensidad, longitud)
incertidumbre_intensidad = 0.02 * intensidad
longitud_diff = np.diff(longitud)
intensidad_promedio = (intensidad[:-1] + intensidad[1:]) / 2
incertidumbre_integral = np.sqrt(
    np.sum((incertidumbre_intensidad[:-1] * longitud_diff)**2)
)
print(f"Energía total radiada: {energia_total:.4e} J")
print(f"Incertidumbre de la energía: {incertidumbre_integral:.4e} J")

#PUNTO 2.A

with open('hysteresis.dat', 'r') as file:
  lines = file.readlines()
# Separar caracteres

Listas = []

for line in lines:
    nueva_cadena = line.replace("\n", "")
    pos = [i for i, char in enumerate(line) if char == '.']


    if line[pos[1]-2] != " ":

        if line[pos[1]-2] == "-":
            nueva_cadena = nueva_cadena[:pos[1]-2] + " " + nueva_cadena[pos[1]-2:]
        else:
            nueva_cadena = nueva_cadena[:pos[1]-1] + " " + nueva_cadena[pos[1]-1:]

    pos = [i for i, char in enumerate(nueva_cadena) if char == '.']

    if nueva_cadena[pos[2]-2] != " ":

        if nueva_cadena[pos[2]-2] == "-":
            nueva_cadena = nueva_cadena[:pos[2]-2] + " " + nueva_cadena[pos[2]-2:]
        else:
            nueva_cadena = nueva_cadena[:pos[2]-1] + " " + nueva_cadena[pos[2]-1:]

    Listas.append( nueva_cadena.split(" ") )

Matriz = np.array(Listas, dtype=float)

tiempo = Matriz[:, 0]
campo_ext = Matriz[:, 1]
densidad = Matriz[:, 2]
fig2, axs2 = plt.subplots(2,1, figsize=(10,10))

#Figura 1
axs2[0].plot(tiempo, densidad,marker='o')
axs2[0].set_xlabel('Tiempo (ms)', fontsize=12)
axs2[0].set_ylabel('Densidad de Campo Interno (A/m)', fontsize=12)
axs2[0].set_title('Densidad de Campo Interno vs Tiempo', fontsize=18)

#Figura 2
axs2[1].plot(tiempo, campo_ext, marker='o')
axs2[1].set_xlabel('Tiempo (ms)', fontsize=12)
axs2[1].set_ylabel('Campo Externo (mT)', fontsize=12)
axs2[1].set_title('Campo Externo (B) vs Tiempo ', fontsize=18)

#Ajuste
plt.tight_layout()

plt.show()

# PUNTO 2B
def sinusoidal(t, A, B, C, D):
    return A * np.sin(B * t + C) + D

p0 = [2, 2 * np.pi * 0.5, 0, 0]

popt, pcov = curve_fit(sinusoidal, tiempo, campo_ext, p0=p0)

A, B, C, D = popt

frecuencia_hz = B / (2 * np.pi)

fig = plt.figure(figsize=(10,10))

plt.plot(tiempo, campo_ext, color = "blue", marker= "o", label='Datos')
plt.plot(tiempo, sinusoidal(tiempo, *popt), 'r-', label='Ajuste')
plt.xlabel('Tiempo (ms)', fontsize=12)
plt.ylabel('Campo Externo (mT)', fontsize=12)
plt.title('Campo Externo (B) vs Tiempo ', fontsize=18)
plt.legend()
plt.tight_layout()
plt.show()


print(f"Ajuste: A * np.sin(B * t + C) + D --> A = {round(A,3)}, B = {round(B,3)}, C = {round(C,3)}, D = {round(D,3)} \n")
print(f"Frecuencia en Hz: {round(frecuencia_hz, 2)} - Se realizó un ajuste sinusoidal a partir del módulo optimize de la librería scipy. "
      "\nAl obtener el omega del ajuste, simplemente se dividió entre 2*pi para obtener la frecuencia.")

#PUNTO 2C
fig = plt.figure(figsize=(6,6))
plt.scatter (densidad, campo_ext, marker='o', color = "blue")
plt.xlabel('Campo Externo (mT)', fontsize=12)
plt.ylabel('Densidad de Campo Interno (A/m)', fontsize=12)
plt.title('Densidad de Campo Interno (H) vs Campo Externo (B)', fontsize=18)

#Ajuste
plt.tight_layout()
plt.show()
plt.show()

B = campo_ext
H = densidad

B_T = B * 0.001

polygon = Polygon(zip(B_T, H))
ordered_coords = np.array(polygon.exterior.coords)
B_sorted, H_sorted = ordered_coords[:, 0], ordered_coords[:, 1]

# Metodo del trapecio
area = np.trapezoid(H_sorted, B_sorted)

print(f"Perdida de energía por unidad de volumen: {abs(area):.4f} J/m³ ")

plt.figure(figsize=(6, 5))
plt.plot(B_sorted * 1000, H_sorted, 'r-', label="Curva ordenada")
plt.fill(B_sorted * 1000, H_sorted, color='gray', alpha=0.3)
plt.xlabel("Campo Externo (mT)")
plt.ylabel("Densidad de Campo Interno (A/m)")
plt.legend()
plt.show()